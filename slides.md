---
# try also 'default' to start simple
theme: default
layout: cover
---

# Hacking the PS4 / PS5 through the PS2 Emulator

---
layout: center
---

# Why the PS2 Emulator ?

##

- It's one of the last remaining parts of the PS5 code that's **JIT privileged**.
- It's basically "unpatchable" : faulty PS2 games won't be fixed, it's part of Sony's policy in order to not be held responsible for the security of third party games

---
layout: center
---

# What is JIT privileged code ?
Just-in-Time compilation

- Essentially, compilation during execution of a program (at run time) rather than before execution.

- The issue is that this violates the W^X (write or execute) principle, thus giving a huge area of attack.

- In the PS5, the PS2 emulator's compiler co-process is vulenable to this.

```mermaid {scale: 1.3, align: center}
graph
A[Compiler] --> B[main application : eboot.bin]
A --> C[compiler child process : ps2-emu-compiler.self]
```

<!--
Goal : control both processes to be able to write and execute arbitrary code
-->

---
layout: image-right
image: images/game.png
---

# Reverse-engineering the PS2 emulator
Thanks to known faulty games !

A simple buffer overflow vunerability was enough to do this.

---
layout : center
---

# The principle :

```mermaid {scale: 1, align: center}
graph LR
subgraph Primitives
A[Primitive 1] --> B[Primitive 2]
B[Primitive 2] --> C[Primitive 3]
C[Primitive 3] --> D[Primitive 4]
C --> E[Primitive 5]
end

F[Emulator Bug]
style F fill:#c61a09

Primitives --> F

G[Booting Custom PS2 games]
style G fill:#00ab41

F --> G
```

---
layout : center
---

# Primitive 1
CDVD commands (Initial Bug on System Commands) : 

- CDVD-S : Special Commands
- CDVD-S : Normal Commands

```mermaid {scale: 1, align: center}
graph LR
S([S command]) -->|Reads| R1[SCMD_SEND / SCMD_STATUS register]
N([N command]) -->|Reads| R2[NCMD_SEND / NCMD_STATUS register]

```

---
layout : center
---

```c {all|4}
      case 0x1f402005: // N_STATUS
        currentbufferoffset = (ulong)nstatusindex;
        nstatusindex = nstatusindex + 1;
        (&nstatusbuffer)[currentbufferoffset] = b;
        bVar3 = DAT_014977d5;
        break;
```
<v-click>

No bound checks â†’ Easy overflow ! 

</v-click>

---
layout : center
---

# Primitive 2
Arbitrary index overwrite : 

We'd like to control *nstatusindex* :

```c {2,4}
      case 0x1f402005: // N_STATUS
        currentbufferoffset = (ulong)nstatusindex;
        nstatusindex = nstatusindex + 1;
        (&nstatusbuffer)[currentbufferoffset] = b;
        bVar3 = DAT_014977d5;
        break;
```

---
layout : center
---

```mermaid {scale: 1, align: center}
flowchart
subgraph Memory
direction LR
N[N Status Buffer, 16 bytes] --- S[S status buffer, 16-bytes]
S --- NI[N status index, 4-bytes] 
NI --- SI[S status index, 4-bytes] 
end
```

<v-click>

We can now control any region after the S status buffer !

</v-click>

---
layout : center
---

# Primitive 3
Arbitrary call with result :

To read/write in memory :

```mermaid {scale: 1, align: center}
flowchart LR
E[Emulator] -->|Call| A[(Array of function pointers)]
A -->|Return result| E
P[Primitive 2] -->|corrupt| A[(Array of function pointers)]
linkStyle 2 stroke:red;
```

<v-click>

We have now achieved arbitrary control flow redirection

</v-click>
